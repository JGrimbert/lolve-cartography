/**
 * CartographyGenerator - G√©n√©ration de cartographie Markdown
 *
 * Responsabilit√©s:
 * - G√©n√©rer une cartographie Markdown des fichiers et m√©thodes
 * - Organiser par cat√©gorie et r√¥le
 * - Formater pour une lecture facile
 */

const fs = require('fs');
const { log } = require('../utils/logger.cjs');
const { writeJSON } = require('../utils/file-utils.cjs');

class CartographyGenerator {
  constructor(fileIndex) {
    this.fileIndex = fileIndex;
  }

  /**
   * Ic√¥nes par r√¥le
   */
  static ROLE_ICONS = {
    core: 'üî∑',
    internal: 'üî∏',
    service: 'üîπ',
    helper: '‚ö™'
  };

  /**
   * Titres des cat√©gories
   */
  static CATEGORY_TITLES = {
    domain: 'üèõÔ∏è Domain (Business model)',
    math: 'üìê Math (Geometric calculations)',
    rendering: 'üé® Rendering (SVG display)',
    ui: 'üñºÔ∏è UI (Interface components)',
    composables: 'üîå Composables (State management)',
    debug: 'üîß Debug (Development tools)',
    utilities: 'üõ†Ô∏è Utilities'
  };

  /**
   * Ordre des cat√©gories
   */
  static CATEGORY_ORDER = ['domain', 'math', 'rendering', 'ui', 'composables', 'debug', 'utilities'];

  /**
   * G√©n√®re une cartographie Markdown compl√®te
   * @param {string|null} outputPath - Chemin de sortie (optionnel)
   * @returns {string} Contenu Markdown
   */
  generate(outputPath = null) {
    const lines = [];

    this.addHeader(lines);
    this.addLegend(lines);
    this.addCategories(lines);

    const content = lines.join('\n');

    if (outputPath) {
      this.saveToFile(outputPath, content);
    }

    return content;
  }

  /**
   * Ajoute l'en-t√™te de la cartographie
   * @private
   */
  addHeader(lines) {
    lines.push('# LOLVE Cartography');
    lines.push('');
    lines.push('> Automatically generated by ContextAgent');
    lines.push(`> Date: ${new Date().toISOString()}`);
    lines.push('');
  }

  /**
   * Ajoute la l√©gende des r√¥les
   * @private
   */
  addLegend(lines) {
    lines.push('## Role Legend');
    lines.push('');
    lines.push('| Icon | Role | Description |');
    lines.push('|------|------|-------------|');
    lines.push('| üî∑ | **core** | Important structural function, orchestration |');
    lines.push('| üî∏ | **internal** | Internal method, consumed by core |');
    lines.push('| üîπ | **service** | External API, called from other classes |');
    lines.push('| ‚ö™ | **helper** | Utility, instantiation |');
    lines.push('');
  }

  /**
   * Ajoute les cat√©gories et leurs fichiers
   * @private
   */
  addCategories(lines) {
    const byCategory = this.groupFilesByCategory();

    for (const category of CartographyGenerator.CATEGORY_ORDER) {
      const files = byCategory[category];
      if (!files || files.length === 0) continue;

      lines.push(`## ${this.getCategoryTitle(category)}`);
      lines.push('');

      for (const { info } of files) {
        this.addFileSection(lines, info);
      }
    }
  }

  /**
   * Groupe les fichiers par cat√©gorie
   * @private
   */
  groupFilesByCategory() {
    const byCategory = {};

    for (const [filePath, info] of Object.entries(this.fileIndex.files)) {
      const cat = info.category || 'other';
      if (!byCategory[cat]) byCategory[cat] = [];
      byCategory[cat].push({ filePath, info });
    }

    return byCategory;
  }

  /**
   * Ajoute une section pour un fichier
   * @private
   */
  addFileSection(lines, info) {
    const { jsdoc } = info;

    // En-t√™te du fichier
    if (jsdoc?.classDoc) {
      lines.push(`### ${jsdoc.classDoc.name}`);
      lines.push(`üìÑ \`${info.path}\``);
      if (jsdoc.classDoc.description) {
        lines.push('');
        lines.push(`> ${jsdoc.classDoc.description}`);
      }
    } else {
      lines.push(`### ${info.name}`);
      lines.push(`üìÑ \`${info.path}\``);
    }
    lines.push('');

    // M√©thodes group√©es par r√¥le
    if (jsdoc?.methods?.length > 0) {
      this.addMethodsByRole(lines, jsdoc.methods);
    }

    // D√©pendances
    if (info.dependencies?.length > 0) {
      lines.push(`**Dependencies:** ${info.dependencies.slice(0, 5).join(', ')}`);
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  /**
   * Ajoute les m√©thodes group√©es par r√¥le
   * @private
   */
  addMethodsByRole(lines, methods) {
    const byRole = { core: [], internal: [], service: [], helper: [], other: [] };

    for (const method of methods) {
      const role = method.role || 'other';
      if (!byRole[role]) byRole[role] = [];
      byRole[role].push(method);
    }

    // Afficher core en premier, puis service, internal, helper
    for (const role of ['core', 'service', 'internal', 'helper']) {
      const roleMethods = byRole[role];
      if (roleMethods.length === 0) continue;

      const icon = CartographyGenerator.ROLE_ICONS[role] || '‚Ä¢';
      lines.push(`**${icon} ${role.toUpperCase()}**`);
      lines.push('');

      for (const method of roleMethods) {
        let methodLine = `- \`${method.name}()\``;
        if (method.description) {
          methodLine += ` ‚Äî ${method.description}`;
        }
        lines.push(methodLine);

        // Consumers pour les services
        if (method.consumers?.length > 0) {
          lines.push(`  - üì• Consumers: ${method.consumers.join(', ')}`);
        }
      }
      lines.push('');
    }
  }

  /**
   * Retourne le titre lisible d'une cat√©gorie
   * @param {string} category - Identifiant de la cat√©gorie
   * @returns {string} Titre format√©
   */
  getCategoryTitle(category) {
    return CartographyGenerator.CATEGORY_TITLES[category] || category;
  }

  /**
   * Sauvegarde la cartographie dans un fichier
   * @private
   */
  saveToFile(outputPath, content) {
    // Hack pour cr√©er le dossier si n√©cessaire
    writeJSON(outputPath.replace('.json', '.md'), null);
    fs.writeFileSync(outputPath, content, 'utf-8');
    log('CartographyGenerator', `Cartography generated: ${outputPath}`, 'success');
  }
}

module.exports = { CartographyGenerator };
