{
  "timestamp": "2026-01-17T11:14:34.194Z",
  "methods": {
    "MethodSearch.findRelevantMethods": {
      "code": "  /**\r\n   * Trouve les méthodes pertinentes pour une requête\r\n   * @param {string} query - Requête utilisateur\r\n   * @param {Object} options - Options de recherche\r\n   * @returns {Array} Liste des méthodes avec leur score\r\n   */\r\n  findRelevantMethods(query, options = {}) {\r\n    const {\r\n      maxMethods = 10,\r\n      minScore = 3,\r\n      roles = null,\r\n      excludeRoles = ['internal'],\r\n      includePrivate = false,\r\n      _isRetry = false  // Internal flag for retry\r\n    } = options;\r\n\r\n    log('MethodSearch', `Searching methods for: \"${query.substring(0, 50)}...\"${_isRetry ? ' (extended scope)' : ''}`);\r\n\r\n    const results = this._doSearch(query, { maxMethods, minScore, roles, excludeRoles, includePrivate });\r\n\r\n    // If no results and not already retrying, try with extended scope\r\n    if (results.length === 0 && !_isRetry) {\r\n      log('MethodSearch', 'No results, retrying with extended scope (including internal/private)...');\r\n      return this._doSearch(query, {\r\n        maxMethods,\r\n        minScore: Math.max(1, minScore - 2),  // Lower threshold too\r\n        roles: null,\r\n        excludeRoles: [],  // Include internal\r\n        includePrivate: true,\r\n        _isRetry: true\r\n      });\r\n    }\r\n\r\n    return results;\r\n  }",
      "normalized": "/** * Trouve les méthodes pertinentes pour une requête * @param { string } query - Requête utilisateur * @param { Object } options - Options de recherche * @returns { Array } Liste des méthodes avec leur score */ findRelevantMethods(query, options = { }){ const { maxMethods = 10, minScore = 3, roles = null, excludeRoles = ['internal'], includePrivate = false, _isRetry = false // Internal flag for retry } = options;log('MethodSearch', `Searching methods for: \"$ { query.substring(0, 50)} ...\"$ { _isRetry ? '(extended scope)' : '' } `);const results = this._doSearch(query, { maxMethods, minScore, roles, excludeRoles, includePrivate });// If no results and not already retrying, try with extended scope if(results.length === 0 && !_isRetry){ log('MethodSearch', 'No results, retrying with extended scope(including internal/private)...');return this._doSearch(query, { maxMethods, minScore: Math.max(1, minScore - 2), // Lower threshold too roles: null, excludeRoles: [], // Include internal includePrivate: true, _isRetry: true });} return results;}",
      "file": "lib\\context\\method-search.cjs",
      "class": "MethodSearch",
      "name": "findRelevantMethods",
      "line": 28,
      "endLine": 56,
      "score": 6
    },
    "ExperienceMemory.findSimilar": {
      "code": "  /**\r\n   * Recherche les expériences similaires\r\n   */\r\n  findSimilar(fingerprint, options = {}) {\r\n    const { limit = 5, minSimilarity = 0.3, excludePending = true } = options;\r\n\r\n    const queryTerms = this.fingerprintToTerms(fingerprint);\r\n    const queryEmbedding = this.tfidf.embed(queryTerms);\r\n\r\n    if (queryEmbedding.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    const results = [];\r\n\r\n    for (const event of this.events) {\r\n      if (excludePending && event.outcome.status === 'pending') {\r\n        continue;\r\n      }\r\n\r\n      const similarity = this.tfidf.cosineSimilarity(queryEmbedding, event.embedding);\r\n\r\n      if (similarity >= minSimilarity) {\r\n        results.push({\r\n          event,\r\n          similarity\r\n        });\r\n      }\r\n    }\r\n\r\n    // Trier par similarité décroissante\r\n    results.sort((a, b) => b.similarity - a.similarity);\r\n\r\n    return results.slice(0, limit);\r\n  }",
      "normalized": "/** * Recherche les expériences similaires */ findSimilar(fingerprint, options = { }){ const { limit = 5, minSimilarity = 0.3, excludePending = true } = options;const queryTerms = this.fingerprintToTerms(fingerprint);const queryEmbedding = this.tfidf.embed(queryTerms);if(queryEmbedding.length === 0){ return [];} const results = [];for(const event of this.events){ if(excludePending && event.outcome.status === 'pending'){ continue;} const similarity = this.tfidf.cosineSimilarity(queryEmbedding, event.embedding);if(similarity >= minSimilarity){ results.push({ event, similarity });}  } // Trier par similarité décroissante results.sort((a, b)=> b.similarity - a.similarity);return results.slice(0, limit);}",
      "file": "lib\\experience-memory.cjs",
      "class": "ExperienceMemory",
      "name": "findSimilar",
      "line": 386,
      "endLine": 417,
      "score": 6
    },
    "SearchSession.getAllLoadedFiles": {
      "code": "  /**\r\n   * Récupère tous les fichiers chargés jusqu'ici\r\n   * @returns {Map} Chemin → contenu\r\n   */\r\n  getAllLoadedFiles() {\r\n    return new Map(this._loadedFiles);\r\n  }",
      "normalized": "/** * Récupère tous les fichiers chargés jusqu'ici * @returns { Map } Chemin → contenu */ getAllLoadedFiles(){ return new Map(this._loadedFiles);}",
      "file": "lib\\context\\search-session.cjs",
      "class": "SearchSession",
      "name": "getAllLoadedFiles",
      "line": 410,
      "endLine": 412,
      "score": 3
    },
    "SearchSession.getAtLevel": {
      "code": "  // ==========================================================================\r\n  // Niveaux de détail progressifs\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Récupère les résultats avec un niveau de détail spécifique\r\n   * @param {number} level - Niveau de détail (0-4)\r\n   *   0: Clés uniquement\r\n   *   1: + descriptions\r\n   *   2: + signatures complètes\r\n   *   3: + code des méthodes\r\n   *   4: + fichiers complets\r\n   * @param {Object} options - Options supplémentaires\r\n   * @returns {Array|Object} Résultats au niveau demandé\r\n   */\r\n  getAtLevel(level = 1, options = {}) {\r\n    const { includeDescriptions = true } = options;\r\n\r\n    switch (level) {\r\n      case 0:\r\n        return this.keys;\r\n\r\n      case 1:\r\n        return this._results.map(({ key, method, score }) => {\r\n          const result = {\r\n            key,\r\n            class: method.class,\r\n            name: method.name,\r\n            role: method.role,\r\n            score\r\n          };\r\n          if (includeDescriptions && method.description) {\r\n            result.description = method.description;\r\n          }\r\n          return result;\r\n        });\r\n\r\n      case 2:\r\n        return this._results.map(({ key, method, score }) => {\r\n          const result = {\r\n            key,\r\n            file: method.file,\r\n            class: method.class,\r\n            signature: method.signature,\r\n            role: method.role,\r\n            effects: method.effects,\r\n            consumers: method.consumers,\r\n            score\r\n          };\r\n          if (includeDescriptions && method.description) {\r\n            result.description = method.description;\r\n          }\r\n          return result;\r\n        });\r\n\r\n      case 3:\r\n        return this._results.map(({ key, method, score }) => {\r\n          if (!this._loadedCode.has(key)) {\r\n            const code = this.agent.methodIndexer.extractMethodCode(key);\r\n            if (code) {\r\n              this._loadedCode.set(key, code);\r\n            }\r\n          }\r\n          const result = {\r\n            key,\r\n            file: method.file,\r\n            class: method.class,\r\n            signature: method.signature,\r\n            role: method.role,\r\n            code: this._loadedCode.get(key) || null,\r\n            score\r\n          };\r\n          if (includeDescriptions && method.description) {\r\n            result.description = method.description;\r\n          }\r\n          return result;\r\n        });\r\n\r\n      case 4:\r\n        const fileGroups = {};\r\n        for (const { key, method } of this._results) {\r\n          const file = method.file;\r\n          if (!fileGroups[file]) {\r\n            const loaded = this.loadFile(file);\r\n            fileGroups[file] = {\r\n              path: file,\r\n              content: loaded?.content || null,\r\n              methods: []\r\n            };\r\n          }\r\n          fileGroups[file].methods.push(key);\r\n        }\r\n        return Object.values(fileGroups);\r\n\r\n      default:\r\n        return this.getAtLevel(1);\r\n    }\r\n  }",
      "normalized": "// ========================================================================== // Niveaux de détail progressifs // ========================================================================== /** * Récupère les résultats avec un niveau de détail spécifique * @param { number } level - Niveau de détail(0-4)* 0: Clés uniquement * 1: + descriptions * 2: + signatures complètes * 3: + code des méthodes * 4: + fichiers complets * @param { Object } options - Options supplémentaires * @returns { Array|Object } Résultats au niveau demandé */ getAtLevel(level = 1, options = { }){ const { includeDescriptions = true } = options;switch(level){ case 0: return this.keys;case 1: return this._results.map(({ key, method, score })=> { const result = { key, class: method.class, name: method.name, role: method.role, score };if(includeDescriptions && method.description){ result.description = method.description;} return result;});case 2: return this._results.map(({ key, method, score })=> { const result = { key, file: method.file, class: method.class, signature: method.signature, role: method.role, effects: method.effects, consumers: method.consumers, score };if(includeDescriptions && method.description){ result.description = method.description;} return result;});case 3: return this._results.map(({ key, method, score })=> { if(!this._loadedCode.has(key)){ const code = this.agent.methodIndexer.extractMethodCode(key);if(code){ this._loadedCode.set(key, code);}  } const result = { key, file: method.file, class: method.class, signature: method.signature, role: method.role, code: this._loadedCode.get(key)|| null, score };if(includeDescriptions && method.description){ result.description = method.description;} return result;});case 4: const fileGroups = { };for(const { key, method } of this._results){ const file = method.file;if(!fileGroups[file]){ const loaded = this.loadFile(file);fileGroups[file] = { path: file, content: loaded?.content || null, methods: [] };} fileGroups[file].methods.push(key);} return Object.values(fileGroups);default: return this.getAtLevel(1);}  }",
      "file": "lib\\context\\search-session.cjs",
      "class": "SearchSession",
      "name": "getAtLevel",
      "line": 429,
      "endLine": 511,
      "score": 3
    },
    "ExperienceMemory.updatePatterns": {
      "code": "  /**\r\n   * Met à jour les statistiques de patterns\r\n   */\r\n  updatePatterns(event, outcome) {\r\n    const signature = this.getPatternSignature(event.task.fingerprint);\r\n\r\n    if (!this.patterns[signature]) {\r\n      this.patterns[signature] = { successes: 0, failures: 0 };\r\n    }\r\n\r\n    if (outcome === 'success') {\r\n      this.patterns[signature].successes++;\r\n    } else {\r\n      this.patterns[signature].failures++;\r\n    }\r\n  }",
      "normalized": "/** * Met à jour les statistiques de patterns */ updatePatterns(event, outcome){ const signature = this.getPatternSignature(event.task.fingerprint);if(!this.patterns[signature]){ this.patterns[signature] = { successes: 0, failures: 0 };} if(outcome === 'success'){ this.patterns[signature].successes++;} else { this.patterns[signature].failures++;}  }",
      "file": "lib\\experience-memory.cjs",
      "class": "ExperienceMemory",
      "name": "updatePatterns",
      "line": 353,
      "endLine": 365,
      "score": 3
    },
    "ExperienceMemory.getStats": {
      "code": "  /**\r\n   * Obtient les statistiques\r\n   */\r\n  getStats() {\r\n    const total = this.events.length;\r\n    const successes = this.events.filter(e => e.outcome.status === 'success').length;\r\n    const failures = this.events.filter(e => e.outcome.status === 'failure').length;\r\n    const pending = this.events.filter(e => e.outcome.status === 'pending').length;\r\n\r\n    return {\r\n      totalEvents: total,\r\n      successes,\r\n      failures,\r\n      pending,\r\n      successRate: total > 0 ? ((successes / (total - pending)) * 100).toFixed(1) + '%' : 'N/A',\r\n      patternsCount: Object.keys(this.patterns).length,\r\n      vocabularySize: this.tfidf.vocabulary.size\r\n    };\r\n  }",
      "normalized": "/** * Obtient les statistiques */ getStats(){ const total = this.events.length;const successes = this.events.filter(e => e.outcome.status === 'success').length;const failures = this.events.filter(e => e.outcome.status === 'failure').length;const pending = this.events.filter(e => e.outcome.status === 'pending').length;return { totalEvents: total, successes, failures, pending, successRate: total > 0 ?((successes /(total - pending))* 100).toFixed(1)+ '%' : 'N/A', patternsCount: Object.keys(this.patterns).length, vocabularySize: this.tfidf.vocabulary.size };}",
      "file": "lib\\experience-memory.cjs",
      "class": "ExperienceMemory",
      "name": "getStats",
      "line": 437,
      "endLine": 452,
      "score": 3
    }
  },
  "files": {
    "lib\\context\\method-search.cjs": {
      "path": "C:\\lolve-cartography\\lib\\context\\method-search.cjs",
      "methods": [
        "MethodSearch.findRelevantMethods"
      ],
      "originalHash": "85b20f89ade4f2b9ce0a13c33d30b84c"
    },
    "lib\\experience-memory.cjs": {
      "path": "C:\\lolve-cartography\\lib\\experience-memory.cjs",
      "methods": [
        "ExperienceMemory.findSimilar",
        "ExperienceMemory.updatePatterns",
        "ExperienceMemory.getStats"
      ],
      "originalHash": "835aae17844744956e5eec8adc896646"
    },
    "lib\\context\\search-session.cjs": {
      "path": "C:\\lolve-cartography\\lib\\context\\search-session.cjs",
      "methods": [
        "SearchSession.getAllLoadedFiles",
        "SearchSession.getAtLevel"
      ],
      "originalHash": "d3827f3a9e03775b2cb94750b1c46b20"
    }
  },
  "hashes": {}
}